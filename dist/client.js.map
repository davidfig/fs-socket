{
  "version": 3,
  "sources": ["../node_modules/cuid/lib/pad.js", "../node_modules/cuid/lib/fingerprint.browser.js", "../node_modules/cuid/lib/getRandomValue.browser.js", "../node_modules/cuid/index.js", "../lib/client.ts"],
  "sourcesContent": ["module.exports = function pad (num, size) {\n  var s = '000000000' + num;\n  return s.substr(s.length - size);\n};\n", "var pad = require('./pad.js');\n\nvar env = typeof window === 'object' ? window : self;\nvar globalCount = Object.keys(env).length;\nvar mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;\nvar clientId = pad((mimeTypesLength +\n  navigator.userAgent.length).toString(36) +\n  globalCount.toString(36), 4);\n\nmodule.exports = function fingerprint () {\n  return clientId;\n};\n", "\nvar getRandomValue;\n\nvar crypto = typeof window !== 'undefined' &&\n  (window.crypto || window.msCrypto) ||\n  typeof self !== 'undefined' &&\n  self.crypto;\n\nif (crypto) {\n    var lim = Math.pow(2, 32) - 1;\n    getRandomValue = function () {\n        return Math.abs(crypto.getRandomValues(new Uint32Array(1))[0] / lim);\n    };\n} else {\n    getRandomValue = Math.random;\n}\n\nmodule.exports = getRandomValue;\n", "/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n *\n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n\nvar fingerprint = require('./lib/fingerprint.js');\nvar pad = require('./lib/pad.js');\nvar getRandomValue = require('./lib/getRandomValue.js');\n\nvar c = 0,\n  blockSize = 4,\n  base = 36,\n  discreteValues = Math.pow(base, blockSize);\n\nfunction randomBlock () {\n  return pad((getRandomValue() *\n    discreteValues << 0)\n    .toString(base), blockSize);\n}\n\nfunction safeCounter () {\n  c = c < discreteValues ? c : 0;\n  c++; // this is not subliminal\n  return c - 1;\n}\n\nfunction cuid () {\n  // Starting with a lowercase letter makes\n  // it HTML element ID friendly.\n  var letter = 'c', // hard-coded allows for sequential access\n\n    // timestamp\n    // warning: this exposes the exact date and time\n    // that the uid was created.\n    timestamp = (new Date().getTime()).toString(base),\n\n    // Prevent same-machine collisions.\n    counter = pad(safeCounter().toString(base), blockSize),\n\n    // A few chars to generate distinct ids for different\n    // clients (so different computers are far less\n    // likely to generate the same id)\n    print = fingerprint(),\n\n    // Grab some more chars from Math.random()\n    random = randomBlock() + randomBlock();\n\n  return letter + timestamp + counter + print + random;\n}\n\ncuid.slug = function slug () {\n  var date = new Date().getTime().toString(36),\n    counter = safeCounter().toString(36).slice(-4),\n    print = fingerprint().slice(0, 1) +\n      fingerprint().slice(-1),\n    random = randomBlock().slice(-2);\n\n  return date.slice(-2) +\n    counter + print + random;\n};\n\ncuid.isCuid = function isCuid (stringToCheck) {\n  if (typeof stringToCheck !== 'string') return false;\n  if (stringToCheck.startsWith('c')) return true;\n  return false;\n};\n\ncuid.isSlug = function isSlug (stringToCheck) {\n  if (typeof stringToCheck !== 'string') return false;\n  var stringLength = stringToCheck.length;\n  if (stringLength >= 7 && stringLength <= 10) return true;\n  return false;\n};\n\ncuid.fingerprint = fingerprint;\n\nmodule.exports = cuid;\n", "import cuid from 'cuid'\nimport {\n    FSSErrors,\n    SocketMessageDir,\n    SocketMessageExists,\n    SocketMessageLogin,\n    SocketMessageReadFile,\n    SocketMessageType,\n    SocketMessageWriteFile,\n} from './types'\n\nexport interface FSSClientOptions {\n    host?: string\n    key?: string\n    authenticate?: string\n    onClose?: () => void\n    onError?: (e: Event) => void\n    debug?: boolean\n}\n\nconst defaultFSSClientOptions = {\n    host: 'ws://localhost:9998',\n    key: '',\n}\n\nexport interface dir {\n    files?: string[]\n    directories?: string[]\n    error: FSSErrors\n}\n\nexport class Client {\n    connectionResolve: (results: boolean) => void\n    options: FSSClientOptions\n    ws: WebSocket\n    ready: boolean\n    waiting: {\n        login?: (results: boolean) => void,\n        directory: { [key: string]: (message: SocketMessageDir) => void },\n        readFile: { [key: string]: (message: SocketMessageReadFile) => void }\n        exists: { [key: string]: (message: SocketMessageExists) => void }\n        writeFile: { [key: string]: (message: SocketMessageWriteFile) => void }\n    } = {\n            directory: {},\n            readFile: {},\n            exists: {},\n            writeFile: {},\n        }\n\n    async connect(clientOptions: FSSClientOptions = {}): Promise<boolean> {\n        return new Promise(resolve => {\n            this.waiting.login = resolve\n            this.options = { ...defaultFSSClientOptions, ...clientOptions }\n            this.ws = new WebSocket(this.options.host)\n            this.ws.addEventListener('open', () => {\n                if (this.options.debug) {\n                    console.log('WebSocket connection opened.')\n                }\n                this.ws.send(JSON.stringify({ type: 'fss-login', key: clientOptions.key }))\n            })\n            this.ws.addEventListener('message', (message: any) => {\n                this.handleMessage(JSON.parse(message.data))\n            })\n            this.ws.addEventListener('close', () => {\n                if (clientOptions.onClose) {\n                    clientOptions.onClose()\n                }\n                if (this.waiting.login) {\n                    this.waiting.login(false)\n                    this.waiting.login = undefined\n                }\n                this.ready = false\n            })\n            this.ws.addEventListener('error', (e: Event) => {\n                if (clientOptions.onError) {\n                    clientOptions.onError(e)\n                }\n                if (this.options.debug) {\n                    console.warn(e)\n                }\n            })\n        })\n    }\n\n    handleMessage(message: SocketMessageType) {\n        if (this.options.debug) {\n            console.log(`Received message ${message.type} from server`)\n        }\n        if (message.type === 'fss-login') {\n            if (this.waiting.login) {\n                const results = (message as SocketMessageLogin).results\n                this.ready = results\n                if (this.options.debug) {\n                    console.log(`Client login was ${results ? 'successful' : 'unsuccessful'}`)\n                }\n                this.waiting.login(results)\n            }\n        } else if (message.type === 'fss-dir') {\n            const messageDir = message as SocketMessageDir\n            this.waiting.directory[messageDir.id](messageDir)\n        } else if (message.type === 'fss-readFile') {\n            const file = message as SocketMessageReadFile\n            this.waiting.readFile[file.id](file)\n        } else if (message.type === 'fss-exists') {\n            const exists = message as SocketMessageExists\n            this.waiting.exists[exists.id](exists)\n        } else if (message.type === 'fss-writeFile') {\n            const write = message as SocketMessageWriteFile\n            this.waiting.writeFile[write.id](write)\n        } else {\n            console.warn(`Received unknown message ${message.type} from server`)\n        }\n    }\n\n    async directory(directory: string, recursive: boolean = true): Promise<SocketMessageDir> {\n        if (!this.ready) {\n            if (this.options.debug) {\n                console.log('Tried to request directory when socket connection was not ready')\n            }\n            return {\n                type: 'fss-dir',\n                directory,\n                recursive,\n                id: '',\n                error: 'FSSClient is not ready',\n            }\n        }\n        return new Promise(resolve => {\n            const id = cuid()\n            this.ws.send(JSON.stringify({\n                type: 'fss-dir',\n                directory,\n                recursive,\n                id,\n            } as SocketMessageDir))\n            this.waiting.directory[id] = resolve\n        })\n    }\n\n    async exists(file: string): Promise<SocketMessageExists> {\n        if (!this.ready) {\n            if (this.options.debug) {\n                console.log('Tried to request directory when socket connection was not ready')\n            }\n            return {\n                type: 'fss-exists',\n                file,\n                id: '',\n                error: 'FSSClient is not ready',\n            } as SocketMessageExists\n        }\n        return new Promise(resolve => {\n            const id = cuid()\n            this.ws.send(JSON.stringify({\n                type: 'fss-exists',\n                file,\n                id\n            } as SocketMessageExists))\n            this.waiting.exists[id] = resolve\n        })\n    }\n\n    async readFile(file: string, fileType: 'binary' | 'json' | 'text' = 'json'): Promise<SocketMessageReadFile> {\n        if (!this.ready) {\n            if (this.options.debug) {\n                console.log('Tried to readFile when socket connection was not ready')\n            }\n            return {\n                type: 'fss-readFile',\n                id: '',\n                file,\n                fileType,\n                error: 'FSSClient is not ready',\n            }\n        }\n        return new Promise(resolve => {\n            const id = cuid()\n            this.ws.send(JSON.stringify({\n                type: 'fss-readFile',\n                file,\n                fileType: fileType || 'json',\n                id,\n            } as SocketMessageReadFile))\n            this.waiting.readFile[id] = resolve\n        })\n    }\n\n    async writeFile(file: string, data: any): Promise<SocketMessageWriteFile> {\n        if (!this.ready) {\n            if (this.options.debug) {\n                console.log('Tried to writeFile when socket connection was not ready')\n            }\n            return {\n                type: 'fss-writeFile',\n                id: '',\n                file,\n                data,\n                error: 'FSSClient is not ready',\n            }\n        }\n        return new Promise(resolve => {\n            const id = cuid()\n            this.ws.send(JSON.stringify({\n                type: 'fss-writeFile',\n                file,\n                data,\n                id,\n            } as SocketMessageWriteFile))\n            this.waiting.writeFile[id] = resolve\n        })\n    }\n}"],
  "mappings": "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",
  "names": []
}
