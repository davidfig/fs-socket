{
  "version": 3,
  "sources": ["../../node_modules/cuid/lib/pad.js", "../../node_modules/cuid/lib/fingerprint.browser.js", "../../node_modules/cuid/lib/getRandomValue.browser.js", "../../node_modules/cuid/index.js", "../../lib/client.ts", "../client.ts"],
  "sourcesContent": ["module.exports = function pad (num, size) {\n  var s = '000000000' + num;\n  return s.substr(s.length - size);\n};\n", "var pad = require('./pad.js');\n\nvar env = typeof window === 'object' ? window : self;\nvar globalCount = Object.keys(env).length;\nvar mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;\nvar clientId = pad((mimeTypesLength +\n  navigator.userAgent.length).toString(36) +\n  globalCount.toString(36), 4);\n\nmodule.exports = function fingerprint () {\n  return clientId;\n};\n", "\nvar getRandomValue;\n\nvar crypto = typeof window !== 'undefined' &&\n  (window.crypto || window.msCrypto) ||\n  typeof self !== 'undefined' &&\n  self.crypto;\n\nif (crypto) {\n    var lim = Math.pow(2, 32) - 1;\n    getRandomValue = function () {\n        return Math.abs(crypto.getRandomValues(new Uint32Array(1))[0] / lim);\n    };\n} else {\n    getRandomValue = Math.random;\n}\n\nmodule.exports = getRandomValue;\n", "/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n *\n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n\nvar fingerprint = require('./lib/fingerprint.js');\nvar pad = require('./lib/pad.js');\nvar getRandomValue = require('./lib/getRandomValue.js');\n\nvar c = 0,\n  blockSize = 4,\n  base = 36,\n  discreteValues = Math.pow(base, blockSize);\n\nfunction randomBlock () {\n  return pad((getRandomValue() *\n    discreteValues << 0)\n    .toString(base), blockSize);\n}\n\nfunction safeCounter () {\n  c = c < discreteValues ? c : 0;\n  c++; // this is not subliminal\n  return c - 1;\n}\n\nfunction cuid () {\n  // Starting with a lowercase letter makes\n  // it HTML element ID friendly.\n  var letter = 'c', // hard-coded allows for sequential access\n\n    // timestamp\n    // warning: this exposes the exact date and time\n    // that the uid was created.\n    timestamp = (new Date().getTime()).toString(base),\n\n    // Prevent same-machine collisions.\n    counter = pad(safeCounter().toString(base), blockSize),\n\n    // A few chars to generate distinct ids for different\n    // clients (so different computers are far less\n    // likely to generate the same id)\n    print = fingerprint(),\n\n    // Grab some more chars from Math.random()\n    random = randomBlock() + randomBlock();\n\n  return letter + timestamp + counter + print + random;\n}\n\ncuid.slug = function slug () {\n  var date = new Date().getTime().toString(36),\n    counter = safeCounter().toString(36).slice(-4),\n    print = fingerprint().slice(0, 1) +\n      fingerprint().slice(-1),\n    random = randomBlock().slice(-2);\n\n  return date.slice(-2) +\n    counter + print + random;\n};\n\ncuid.isCuid = function isCuid (stringToCheck) {\n  if (typeof stringToCheck !== 'string') return false;\n  if (stringToCheck.startsWith('c')) return true;\n  return false;\n};\n\ncuid.isSlug = function isSlug (stringToCheck) {\n  if (typeof stringToCheck !== 'string') return false;\n  var stringLength = stringToCheck.length;\n  if (stringLength >= 7 && stringLength <= 10) return true;\n  return false;\n};\n\ncuid.fingerprint = fingerprint;\n\nmodule.exports = cuid;\n", "import cuid from 'cuid'\nimport {\n    FSSErrors,\n    SocketMessageDir,\n    SocketMessageExists,\n    SocketMessageLogin,\n    SocketMessageReadFile,\n    SocketMessageType,\n    SocketMessageWriteFile,\n} from './types'\n\nexport interface FSSClientOptions {\n    host?: string\n    key?: string\n    authenticate?: string\n    onClose?: () => void\n    onError?: (e: Event) => void\n    debug?: boolean\n}\n\nconst defaultFSSClientOptions = {\n    host: 'ws://localhost:9998',\n    key: '',\n}\n\nexport interface dir {\n    files?: string[]\n    directories?: string[]\n    error: FSSErrors\n}\n\nexport class Client {\n    connectionResolve: (results: boolean) => void\n    options: FSSClientOptions\n    ws: WebSocket\n    ready: boolean\n    waiting: {\n        login?: (results: boolean) => void,\n        directory: { [key: string]: (message: SocketMessageDir) => void },\n        readFile: { [key: string]: (message: SocketMessageReadFile) => void }\n        exists: { [key: string]: (message: SocketMessageExists) => void }\n        writeFile: { [key: string]: (message: SocketMessageWriteFile) => void }\n    } = {\n            directory: {},\n            readFile: {},\n            exists: {},\n            writeFile: {},\n        }\n\n    async connect(clientOptions: FSSClientOptions = {}): Promise<boolean> {\n        return new Promise(resolve => {\n            this.waiting.login = resolve\n            this.options = { ...defaultFSSClientOptions, ...clientOptions }\n            this.ws = new WebSocket(this.options.host)\n            this.ws.addEventListener('open', () => {\n                if (this.options.debug) {\n                    console.log('WebSocket connection opened.')\n                }\n                this.ws.send(JSON.stringify({ type: 'fss-login', key: clientOptions.key }))\n            })\n            this.ws.addEventListener('message', (message: any) => {\n                this.handleMessage(JSON.parse(message.data))\n            })\n            this.ws.addEventListener('close', () => {\n                if (clientOptions.onClose) {\n                    clientOptions.onClose()\n                }\n                if (this.waiting.login) {\n                    this.waiting.login(false)\n                    this.waiting.login = undefined\n                }\n                this.ready = false\n            })\n            this.ws.addEventListener('error', (e: Event) => {\n                if (clientOptions.onError) {\n                    clientOptions.onError(e)\n                }\n                if (this.options.debug) {\n                    console.warn(e)\n                }\n            })\n        })\n    }\n\n    handleMessage(message: SocketMessageType) {\n        if (this.options.debug) {\n            console.log(`Received message ${message.type} from server`)\n        }\n        if (message.type === 'fss-login') {\n            if (this.waiting.login) {\n                const results = (message as SocketMessageLogin).results\n                this.ready = results\n                if (this.options.debug) {\n                    console.log(`Client login was ${results ? 'successful' : 'unsuccessful'}`)\n                }\n                this.waiting.login(results)\n            }\n        } else if (message.type === 'fss-dir') {\n            const messageDir = message as SocketMessageDir\n            this.waiting.directory[messageDir.id](messageDir)\n        } else if (message.type === 'fss-readFile') {\n            const file = message as SocketMessageReadFile\n            this.waiting.readFile[file.id](file)\n        } else if (message.type === 'fss-exists') {\n            const exists = message as SocketMessageExists\n            this.waiting.exists[exists.id](exists)\n        } else if (message.type === 'fss-writeFile') {\n            const write = message as SocketMessageWriteFile\n            this.waiting.writeFile[write.id](write)\n        } else {\n            console.warn(`Received unknown message ${message.type} from server`)\n        }\n    }\n\n    async directory(directory: string, recursive: boolean = true): Promise<SocketMessageDir> {\n        if (!this.ready) {\n            if (this.options.debug) {\n                console.log('Tried to request directory when socket connection was not ready')\n            }\n            return {\n                type: 'fss-dir',\n                directory,\n                recursive,\n                id: '',\n                error: 'FSSClient is not ready',\n            }\n        }\n        return new Promise(resolve => {\n            const id = cuid()\n            this.ws.send(JSON.stringify({\n                type: 'fss-dir',\n                directory,\n                recursive,\n                id,\n            } as SocketMessageDir))\n            this.waiting.directory[id] = resolve\n        })\n    }\n\n    async exists(file: string): Promise<SocketMessageExists> {\n        if (!this.ready) {\n            if (this.options.debug) {\n                console.log('Tried to request directory when socket connection was not ready')\n            }\n            return {\n                type: 'fss-exists',\n                file,\n                id: '',\n                error: 'FSSClient is not ready',\n            } as SocketMessageExists\n        }\n        return new Promise(resolve => {\n            const id = cuid()\n            this.ws.send(JSON.stringify({\n                type: 'fss-exists',\n                file,\n                id\n            } as SocketMessageExists))\n            this.waiting.exists[id] = resolve\n        })\n    }\n\n    async readFile(file: string, fileType: 'binary' | 'json' | 'text' = 'json'): Promise<SocketMessageReadFile> {\n        if (!this.ready) {\n            if (this.options.debug) {\n                console.log('Tried to readFile when socket connection was not ready')\n            }\n            return {\n                type: 'fss-readFile',\n                id: '',\n                file,\n                fileType,\n                error: 'FSSClient is not ready',\n            }\n        }\n        return new Promise(resolve => {\n            const id = cuid()\n            this.ws.send(JSON.stringify({\n                type: 'fss-readFile',\n                file,\n                fileType: fileType || 'json',\n                id,\n            } as SocketMessageReadFile))\n            this.waiting.readFile[id] = resolve\n        })\n    }\n\n    async writeFile(file: string, data: any): Promise<SocketMessageWriteFile> {\n        if (!this.ready) {\n            if (this.options.debug) {\n                console.log('Tried to writeFile when socket connection was not ready')\n            }\n            return {\n                type: 'fss-writeFile',\n                id: '',\n                file,\n                data,\n                error: 'FSSClient is not ready',\n            }\n        }\n        return new Promise(resolve => {\n            const id = cuid()\n            this.ws.send(JSON.stringify({\n                type: 'fss-writeFile',\n                file,\n                data,\n                id,\n            } as SocketMessageWriteFile))\n            this.waiting.writeFile[id] = resolve\n        })\n    }\n}", "import { Client } from '../lib/client'\n\nlet client: Client\n\nasync function initWrongKey() {\n    let s = '<div class=\"description\">Initializing fs-socket with wrong key...</div>'\n    s += '<div class=\"code\">const client = new Client();</div>'\n    client = new Client()\n    const connected = await client.connect()\n    if (connected) {\n        s += '<div class=\"error\">server accepted connection with wrong key</div>'\n    } else {\n        s += '<div class=\"server\">server properly rejected connection with wrong key</div>'\n    }\n    return s\n}\n\nasync function initCorrectKey() {\n    let s = ''\n    s += '<div class=\"description\">Initializing fs-socket with correct key...</div>'\n    s += '<div class=\"code\">const client = new Client({ key: \\'this is a nice key...\\' });</div>'\n    const connected = await client.connect({\n        debug: true,\n        key: \"this is a nice key...\",\n    })\n    if (connected) {\n        s += '<div class=\"server\">client successfully connected</div>'\n    } else {\n        s += '<div class=\"error\">client did not successfully connect!</div>'\n    }\n    return s\n}\n\nasync function directory() {\n    let s = ''\n    s += '<div class=\"description\">recursive dir listing for \"sample\"...</div>'\n    s += '<div class=\"code\">client.directory(\\'sample\\', true);</div>'\n    const dir = await client.directory('sample', true)\n    s += '<div class=\"server\">'\n    for (const file of dir.files) {\n        s += ` - ${file}<br>`\n    }\n    s += '</div>'\n    return s\n}\n\nasync function doesNotExist() {\n    let s = ''\n    s += '<div class=\"description\">exists for \"sample/does-not-exist...</div>'\n    s += '<div class=\"code\">client.exists(\\'sample/does-not-exist\\');</div>'\n    const exists = await client.exists('sample/does-not-exist')\n    s += `<div class=\"server\">file ${exists.exists ? 'exists' : 'does not exist'}</div>`\n    return s\n}\n\nasync function exists() {\n    let s = ''\n    s += '<div class=\"description\">exists for \"sample/test.json...</div>'\n    s += '<div class=\"code\">client.exists(\\'sample/test.json\\');</div>'\n    const exists = await client.exists('sample/test.json')\n    s += `<div class=\"server\">file ${exists.exists ? 'exists' : 'does not exist'}</div>`\n    return s\n}\n\nasync function readFileText() {\n    let s = ''\n    s += '<div class=\"description\">readFile using text for \"sample/server.ts...</div>'\n    s += '<div class=\"code\">client.readFile(\\'sample/server.ts\\', \\'text\\');</div>'\n    const dir = await client.readFile('sample/server.ts', 'text')\n    s += `<div class=\"server\">${dir.data.substring(0, 30)}...</div>` +\n        '</div>'\n    return s\n}\n\nasync function readFileJson() {\n    let s = ''\n    s += '<div class=\"description\">readFile using json for \"sample/test.json...</div>'\n    s += '<div class=\"code\">client.readFile(\\'sample/test.json\\', true);</div>'\n    const dir = await client.readFile('sample/test.json', 'json')\n    s += `<div class=\"server\">${JSON.stringify(dir.data).substring(0, 30)}...</div>` +\n        '</div>'\n    return s\n}\n\nasync function readFileBinary() {\n    let s = ''\n    s += '<div class=\"description\">readFile using binary for \"sample/test.json...</div>'\n    s += '<div class=\"code\">client.readFile(\\'sample/test.json\\', true);</div>'\n    const dir = await client.readFile('sample/test.json', 'json')\n    s += `<div class=\"server\">${JSON.stringify(dir.data).substring(0, 30)}...</div>` +\n        '</div>'\n    return s\n}\n\nasync function writeFile() {\n    const r = Math.random()\n    let s = ''\n    s += '<div class=\"description\">readFile using binary for \"sample/test.json...</div>'\n    s += `<div class=\"code\">client.writeFile('sample/test.txt');</div>`\n    s += `<div class=\"code\">// this is a test file...${r}</div>`\n    const write = await client.writeFile('sample/write-test.txt', `this is a text file...${r}`)\n    if (write.error) {\n        s += `<div class='server'>${write.error}</div>`\n    } else {\n        s += '<div class=\"server\">File successfully written.</div>'\n    }\n    return s\n}\n\nasync function start() {\n    const s = await initWrongKey() +\n        await initCorrectKey() +\n        await directory() +\n        await readFileText() +\n        await readFileJson() +\n        await readFileBinary() +\n        await doesNotExist() +\n        await exists() +\n        await writeFile()\n    document.querySelector('.results').innerHTML = s\n}\n\nwindow.onload = start"],
  "mappings": "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",
  "names": []
}
